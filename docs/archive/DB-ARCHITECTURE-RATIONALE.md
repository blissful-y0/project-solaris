# Phase 2 DB 구조 설계 이유서 (비개발자용)

> 작성: 2026-02-18
> 대상: 기획/운영/디자인/PM 포함 전체 팀

---

## 이 문서는 무엇을 설명하나요?

이 문서는 "DB를 어떻게 만들었는지"보다, **"왜 그렇게 만들었는지"**를 설명합니다.
핵심 목표는 3가지였습니다.

1. 운영 사고를 줄인다.
2. 승인/알림 같은 핵심 흐름이 자동으로 굴러가게 만든다.
3. 나중에 기능이 커져도 구조가 무너지지 않게 한다.

---

## 1) 사용자/캐릭터를 왜 이렇게 묶었나?

### 결정

- `users.id`를 Supabase Auth의 `auth.uid`(UUID)와 동일하게 사용
- 유저당 캐릭터 1개만 허용

### 이유

- 로그인 계정과 앱 사용자 레코드가 1:1로 딱 맞아야 인증/권한 문제가 줄어듭니다.
- "한 사람 여러 캐릭터"를 열어두면 승인 정책, 리더 선발, 운영 기준이 급격히 복잡해집니다.
- 현재 운영 방식(신청/승인 중심)에서는 단일 캐릭터가 가장 관리 비용이 낮습니다.

### 기대효과

- 권한 버그 감소
- 운영 의사결정 단순화
- 승인 큐 처리 속도 향상

---

## 2) 왜 승인 상태를 단순화했나?

### 결정

- 캐릭터 상태를 `pending | approved | rejected` 3단계로 제한

### 이유

- 상태가 많아질수록 운영/UX/알림 분기가 폭발적으로 늘어납니다.
- 초기 단계에서는 "대기/통과/탈락"이 명확한 커뮤니케이션에 유리합니다.
- 팀 내 해석 차이를 줄이기 위해 최소 상태 모델을 선택했습니다.

### 기대효과

- 화면/알림/관리자 API가 단순해짐
- 테스트 케이스 수 감소
- 운영 기준 일관성 확보

---

## 3) 왜 진영별 리더 1명을 DB가 강제하나?

### 결정

- Bureau/Static 리더는 각 1명만 허용되도록 DB 유니크 제약 적용

### 이유

- "운영자가 수동으로 잘 관리하면 된다"는 전제는 동시 작업 시 깨질 수 있습니다.
- 관리자 2명이 거의 동시에 리더를 지정하면 중복 리더가 생길 수 있습니다.
- 이런 문제는 앱 코드보다 DB 제약으로 막는 것이 확실합니다.

### 기대효과

- 동시성 상황에서도 규칙 보장
- 운영 실수로 인한 데이터 오염 예방

---

## 4) 알림 구조를 왜 DB 중심으로 설계했나?

### 결정

- 모든 알림은 먼저 `notifications` 테이블에 기록
- 그 후 디스코드(DM/Webhook) 전송은 비동기로 처리

### 이유

- 디스코드 전송은 외부 서비스라 실패할 수 있습니다.
- 외부 전송 실패 때문에 핵심 기능(승인/반려)이 실패하면 운영이 멈춥니다.
- 먼저 DB에 기록하면 "알림 이력"이 남고, 실패 재시도도 가능해집니다.

### 기대효과

- 장애 내성 확보 (디스코드 장애 시에도 앱은 정상 동작)
- 알림 추적 가능 (`pending/sent/failed`)
- 재처리 자동화 기반 확보

---

## 5) 왜 디스코드는 DM과 Webhook을 분리했나?

### 결정

- 개인 알림: Bot DM
- 전체 공지/스토리: Webhook

### 이유

- 개인 알림을 채널 웹훅으로 보내면 불필요한 공개 노출 위험이 있습니다.
- 반대로 전체 공지는 DM보다 채널 발행이 운영 효율이 높습니다.
- 알림 성격에 맞는 채널을 분리하는 것이 커뮤니티 운영에 유리합니다.

### 기대효과

- 개인정보/운영 리스크 감소
- 전달 효율 개선

---

## 6) 왜 트리거(자동 호출)를 붙였나?

### 결정

- `notifications` INSERT 시 `notify` 함수를 자동 호출하는 DB 트리거 적용

### 이유

- 사람이 수동으로 "알림 전송" 버튼을 누르는 구조는 누락이 발생합니다.
- 이벤트 발생 시 자동으로 호출되어야 운영 품질이 일정해집니다.

### 기대효과

- 승인/반려 후 디스코드 알림 누락 방지
- 운영 의존도 감소

---

## 7) 왜 마이그레이션을 CLI 중심으로 고정했나?

### 결정

- 스키마 변경은 CLI 마이그레이션 파일로만 관리

### 이유

- SQL Editor 수동 반영은 기록이 흩어져 재현이 어렵습니다.
- 운영/개발 환경이 서로 다른 스키마로 갈라지는 문제를 막아야 합니다.

### 기대효과

- "언제 무엇을 바꿨는지" 추적 가능
- 배포 안정성 향상

---

## 8) 이번 구조로 얻는 실제 운영 이점

1. 승인/반려 처리 속도가 빨라짐
2. 리더 중복 같은 규칙 위반을 DB가 자동 차단
3. 디스코드 장애가 나도 앱 운영은 지속
4. 알림 누락/유실 추적이 가능
5. 향후 관리자 페이지/통계 기능 확장 기반 확보

---

## 9) 남은 운영 세팅 (코드 외)

아래는 코드 구현이 아니라 운영 설정입니다.

- Edge Function Secrets 입력
- DB Webhook 트리거 동작 검증
- 테스트 알림 1건으로 `delivery_status` 전이 확인

실행 순서 문서는 아래에 별도로 정리되어 있습니다.

- `docs/plans/2026-02-18-discord-secrets-webhook-runbook.md`

---

## 한 줄 결론

이번 DB 구조는 "기능을 만들기 위한 설계"가 아니라,
**"운영 중에 깨지지 않게 하기 위한 설계"**를 우선한 결과입니다.
